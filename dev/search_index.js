var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TruncatedStreams","category":"page"},{"location":"#TruncatedStreams","page":"Home","title":"TruncatedStreams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TruncatedStreams.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TruncatedStreams]","category":"page"},{"location":"#TruncatedStreams.FixedLengthSource","page":"Home","title":"TruncatedStreams.FixedLengthSource","text":"FixedLengthSource(io, length) <: TruncatedSource\n\nA truncated source that reads io up to length bytes.\n\njulia> io = IOBuffer(collect(0x00:0xff));\n\njulia> fio = FixedLengthSource(io, 10);\n\njulia> read(fio)\n10-element Vector{UInt8}:\n 0x00\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n 0x09\n\njulia> eof(fio)\ntrue\n\nAs soon as a read from a FixedLengthSource object would read past length bytes of the underlying IO stream, EOF is signalled, potentially leading to an EOFError being thrown.\n\njulia> read(fio, Int)\nERROR: EOFError: read end of file\n[...]\n\nSeeking does not affect the length at which the stream is truncated, but may affect how many bytes are available to read.\n\njulia> seek(fio, 8); read(fio)\n2-element Vector{UInt8}:\n 0x08\n 0x09\n\n\n\n\n\n","category":"type"},{"location":"#TruncatedStreams.SentinelizedSource","page":"Home","title":"TruncatedStreams.SentinelizedSource","text":"SentinelizedSource(io, sentinel) <: TruncatedSource\n\nA truncated source that reads io until sentinel is found.\n\njulia> io = IOBuffer(repeat(collect(0x00:0x0f), 2));\n\njulia> sio = SentinelizedSource(io, [0x0a, 0x0b]);\n\njulia> read(sio)\n10-element Vector{UInt8}:\n 0x00\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n 0x09\n\njulia> eof(sio)\ntrue\n\nAs soon as a read from a SentinelizedSource object would read the start of a byte sequence matching sentinel from the underlying IO stream, EOF is signalled, potentially leading to an EOFError being thrown.\n\njulia> read(sio, Int)\nERROR: EOFError: read end of file\n[...]\n\nSeeking works as if the stream ends at the first byte of the sentinel: backwards seeking will always succeed if the wrapped stream allows it, and forward seeking will only seek up to the sentinel. Note that forward seeking will consume bytes from the wrapped stream.\n\njulia> seek(sio, 8); read(sio)\n2-element Vector{UInt8}:\n 0x08\n 0x09\n\nDetection of eof can be reset with the Base.reseteof() method. Use this if the sentinel that was read is determined upon further inspection to be bogus.\n\njulia> Base.reseteof(sio)  # that last sentinel was fake, so reset EOF and read again\n\njulia> read(sio)  # returns the first sentinel found and continues to read until the next one is found\n16-element Vector{UInt8}:\n 0x0a\n 0x0b\n 0x0c\n 0x0d\n 0x0e\n 0x0f\n 0x00\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n 0x09\n\nnote: Note\nIf the wrapped stream does not contain a sentinel, reading to the end of the stream will throw EOFError.\n\njulia> io = IOBuffer(collect(0x00:0x07)); sio = SentinelizedSource(io, [0xff, 0xfe]);\n\njulia> read(sio)\nERROR: EOFError: read end of file\n[...]\n\n\n\n\n\n","category":"type"},{"location":"#TruncatedStreams.TruncatedSource","page":"Home","title":"TruncatedStreams.TruncatedSource","text":"TruncatedSource <: IO\n\nWrap an IO object to read only as much as should be read and not a byte more.\n\nObjects inheriting from this abstract type pass along all read-oriented IO methods to the wrapped stream except for bytesavailable(io) and eof(io). Inherited types must implement:\n\nTruncatedStreams.unwrap(::TruncatedSource)::IO: return the wrapped IO stream.\nBase.eof(::TruncatedSource)::Bool: report whether the stream cannot produce any more bytes.\n\nIn order to implement truncation, some number of these methods will likely need to be implemented:\n\nBase.unsafe_read(::TruncatedSource, p::Ptr{UInt8}, n::UInt)::Nothing: copy n bytes from the   stream into memory pointed to by p.\nBase.read(::TruncatedSource, T::Type)::T: read and return an object of type T from the stream.\nBase.bytesavailable(::TruncatedSource)::Int: report the number of bytes available to read from   the stream until EOF or a buffer refill is necessary.\nBase.seek(::TruncatedSource, p::Integer) and Base.seekend(::TruncatedSource): seek stream to   position p or end of stream.\nBase.reset(::TruncatedSource): reset a marked stream to the saved position.\nBase.reseteof(::TruncatedSource)::Nothing: reset EOF status.\nBase.peek(::TruncatedSource[, T::Type])::T: read and return the next object of type T from the   stream, but leave the bytes available in the stream for the next read.\n\nThe following methods must be implemented by the wrapped IO type for all the functionality of the     TruncatedSource to work at all:\n\nBase.eof(::IO)::Bool\nBase.read(::IO, ::Type{UInt8})::UInt8\n\nThe wrapped stream also must implement Base.seek and Base.skip for seeking and skipping of the truncated stream to work properly. Additionally, Base.position needs to be implemented for some implementations of Base.seek to work properly.\n\n\n\n\n\n","category":"type"},{"location":"#TruncatedStreams.unwrap","page":"Home","title":"TruncatedStreams.unwrap","text":"unwrap(s<:TruncatedSource{T}) -> T where {T <: IO}\n\nReturn the wrapped source.\n\n\n\n\n\n","category":"function"}]
}
